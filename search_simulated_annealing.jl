using Graphs
using Random
using ProgressMeter

include("bayesian_score_calc.jl")

"""
    random_neighbor(g::SimpleDiGraph)

Generates a single, valid, random neighbor of a graph 'g'.
A neighbor is generated by attempting a single random operation (add, remove, or reverse edge).
It returns the new graph if the operation is valid (results in a DAG), otherwise it returns the original graph.
"""
function random_neighbor(g::SimpleDiGraph)
    n = nv(g)
    g_new = copy(g)

    # Pick two distinct nodes at random
    i, j = rand(1:n, 2)
    while i == j
        i, j = rand(1:n, 2)
    end

    # Randomly choose an operation
    op = rand(1:3) 

    if has_edge(g, i, j)
        # Options: remove or reverse
        if op <= 2 # Give higher chance to remove/reverse
            rem_edge!(g_new, i, j)
            # Try reversing
            if op == 2 && !has_edge(g, j, i)
                add_edge!(g_new, j, i)
                if is_cyclic(g_new)
                    return g # Invalid move, return original
                end
            end
        end
    else
        # Option: add edge
        add_edge!(g_new, i, j)
        if is_cyclic(g_new)
            return g # Invalid move, return original
        end
    end
    return g_new
end


"""
    simulated_annealing(vars, data; initial_temp=100.0, min_temp=0.1, cool_rate=0.99, max_iter=5000)

Performs simulated annealing to find a high-scoring Bayesian network structure.
"""
function simulated_annealing(vars, data; 
                             initial_temp::Float64=100.0, 
                             min_temp::Float64=0.1, 
                             cool_rate::Float64=0.99, 
                             max_iter::Int=5000)
    
    n = length(vars)
    
    # Start with an empty graph
    current_graph = SimpleDiGraph(n)
    current_score = bayesian_score(vars, current_graph, data)
    
    best_graph = copy(current_graph)
    best_score = current_score
    
    temp = initial_temp
    
    @showprogress "Simulated Annealing: " for iter in 1:max_iter
        if temp <= min_temp
            break
        end

        # 1. Generate a random neighbor
        new_graph = random_neighbor(current_graph)
        
        # If random_neighbor returned the same graph, skip to next iteration
        if new_graph == current_graph
            continue
        end

        # 2. Score the new graph
        new_score = bayesian_score(vars, new_graph, data)
        
        # 3. Decide whether to accept the new state
        score_diff = new_score - current_score
        
        # Acceptance condition:
        # - Always accept if the new score is better.
        # - If the new score is worse, accept with a probability exp(diff/temp).
        if score_diff > 0 || rand() < exp(score_diff / temp)
            current_graph = new_graph
            current_score = new_score
        end
        
        # 4. Update the best-ever solution found
        if current_score > best_score
            best_score = current_score
            best_graph = current_graph
        end
        
        # 5. Cool the temperature
        temp *= cool_rate
    end
    
    return best_graph, best_score
end